```@meta
CurrentModule = Oscar
```

```@setup oscar
using Oscar
```

```@contents
Pages = ["groups.md"]
```

# Groups


Oscar supports the following types of groups:

* `PermGroup` = groups of permutations
* `MatrixGroup` = groups of matrices
* `FPGroup` = finitely presented groups
* `PcGroup` = polycyclic groups
* `DirectProductOfGroups` = direct product of two groups
* `AutomorphismGroup` = group of automorphisms over a group


If `x` is an element of the group `G` of type `T`, then the type of `x` is `GAPGroupElement{T}`.

## Basics

### Elements of groups

Given a group `G`, it is always possible to have access to some particular elements.

```@docs
one(x::GAPGroup)
rand(::GAPGroup)
rand_pseudo(G::GAPGroup)
gens(::GAPGroup)
```

If the group `G` has been created as the subgroup of another group generated by a list of elements `L`, then the generating set returned by the function `gens` corresponds to `L`.

!!! note
    The output of `gens(G)` is not, in general, the minimal list of generators for `G`.

### Operations

Oscar supports the following operations and functions on group elements.

* `*` = multiplication between two elements in a group.
* `inv(x)` = `x^-1` the inverse of `x`.
* `x/y` = the element `x*y^-1`.
* `x^n` = the ``n``-th power of `x`. If ``n = 0``, the identity of the group is returned; if ``n < 0 ``, the ``n``-th power of the inverse of `x` is returned.
* `isone(x)`: returns whether `x` is the identity of the group.
* `conj(x,y)` = `x^y` = the conjugate of `x` by `y`, i.e. the element `x^-1*y*x`.
* `comm(x,y)` = the commutator of `x` and `y`, i.e. the element `x^-1*y^-1*x*y`.


## Subgroups

The subgroup of a group `G` generated by the elements `x,y,...` are defined by the following instruction:

* `sub(G, [x,y,...])` ;
* `sub(x,y,...)`.

This function returns two objects: a group `H`, that is the subgroup of `G` generated by the elements `x,y,...`, and the embedding homomorphism of `H` into `G`. The object `H` has the same type of `G`, and it has no memory of the "parent" group `G`: it is an independent group.

  **Examples:**
```jldoctest
julia> G = symmetric_group(4); H = sub(G,[cperm([1,2,3]),cperm([2,3,4])]);
julia> H[1] == alternating_group(4)
true
```


## Permutation groups

Permutation groups can be defined as symmetric groups, alternating groups or their subgroups.

```@docs
symmetric_group
alternating_group
```

Every permutation group `G` is identified by a degree, that corresponds ideally to the size of the set on which `G` is acting.

!!! note
    The degree of a group of permutations is not necessarily the highest moved point of the group `G`. For example, if `G` is defined as a   subgroup of `Sym(n)`, its degree is `n` even if every element of `G` fixes `n`.

### Permutations

Permutations in Oscar are displayed as products of disjoint cycles, as in GAP. An explicit permutation can be built using the functions `perm`, `gap_perm` and `cperm`.

```@docs
perm
gap_perm
cperm
```

  **Example:**
```jldoctest
julia> perm(symmetric_group(6),[2,4,6,1,3,5])
(1,2,4)(3,6,5)

julia> cperm([1,2,3],4:7)
(1,2,3)(4,5,6,7)

julia> cperm([1,2],[2,3])
(1,3,2)
```

At the moment, the input vectors of the function `cperm` need not to be disjoint.

!!! warning
    If the function `perm` is evaluated in a vector of integers without specifying the group `G`, then the returned value is an element of the AbstractAlgebra.jl type `Perm{Int}`. For this reason, if one wants a permutation of type `GAPGroupElem{PermGroup}`, one has to use the function `gap_perm`.


Every permutation has always a permutation group as a parent. Two permutations coincide if, and only if, they have the same parent and they move the same points.
```jldoctest
julia> G=symmetric_group(5);
julia> x=cperm([1,2]);
julia> y=cperm(G,[1,2]);
julia> x==y
false
```
In the example above, `x` and `y` are different because `x` belongs to `Sym(2)`, while `y` belongs to `Sym(5)`.


If `G` is a group and `x` is a permutation, it is possible to set `G` as parent of `x` simply typing `G(x)`. This returns the permutation `x` as element of `G` (or ERROR if `x` does not embed into `G`).
```@repl oscar
G=symmetric_group(5);
x=cperm([1,2,3]);
y=G(x);
parent(x)
parent(y)
```

The function `listperm` works in the opposite way with respect to `perm`: given a permutation `x`, it returns the vector `[x(1), ... , x(n)]`, where `n` is the degree of `parent(x)`. If `x` and `y` are as in the example above, we get
```@repl oscar
(x,y) = (cperm([1,2,3]), cperm(symmetric_group(5),[1,2,3])) # hide
listperm(x)
listperm(y)
```


#### Permutations as functions
A permutation can be viewed as a function on the set `{1,...,n}`, hence it can be evaluated on integers.
```jldoctest
julia> x = cperm([1,2,3,4,5]);
julia> x(2)
3
```
This works also if the argument is not in the range `1:n`; in such a case, the output coincides with the input.

!!! note
    The multiplication between permutations works from the left to the right. So, if `x` and `y` are permutations and `n` is an integer, then `(x*y)(n) = (y(x(n))`, NOT `x(y(n))`.


## Polycyclic groups

Julia has the following functions that allow to generate polycyclic groups:
```@docs
abelian_group(::Type{T}, v::Vector{Int}) where T <: GAPGroup
cyclic_group
dihedral_group
quaternion_group
```
!!! warning
    The type need to be specified in the input of the function `abelian_group`, otherwise a group of type `GrpAbFinGen` is returned.

The generators of a polycyclic group are displayed as `f1`, `f2`, `f3`, etc., and every element of a polycyclic group is displayed as product of such generators.

  **Example:**
```jldoctest
julia> G=abelian_group(PcGroup, [2,4]);
julia> G[1], G[2]
(f1, f2)
julia> G[2]*G[1]
f1*f2
```
Anyway, recall that variables named `f1`, `f2`, etc. are not initialized! To get the generators of the group `G`, one has to refer to them as `G[1]`, `G[2]`, etc.
