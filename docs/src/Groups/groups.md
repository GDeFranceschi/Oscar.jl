```@meta
CurrentModule = Oscar
```

```@setup oscar
using Oscar
```

```@contents
Pages = ["groups.md"]
```

# Groups


Oscar supports the following types of groups:

* `PermGroup` = groups of permutations
* `MatrixGroup` = groups of matrices
* `FPGroup` = finitely presented groups
* `PcGroup` = polycyclic groups
* `DirectProductOfGroups` = direct product of two groups
* `AutomorphismGroup` = group of automorphisms over a group


If `x` is an element of the group `G` of type `T`, then the type of `x` is `GAPGroupElement{T}`.

The subtype `BasicGAPGroupElem{T}` of `GAPGroupElem{T}` encompasses elements of all the groups that rely uniquely on an undelying GAP object. This is the case of all the groups listed above, with the exception of `MatrixGroup`.

## Basics

### [Elements of groups](@id elements_of_groups)

Given a group `G`, it is always possible to have access to some particular elements.

```@docs
one(x::GAPGroup)
rand(::GAPGroup)
rand_pseudo(G::GAPGroup)
gens(::GAPGroup)
gen(::GAPGroup, i::Int)
```

It is also possible to obtain the generators of `G` by typing
```julia
f1,f2,f3 = gens(G)
```
This is equivalent to
```julia
f1=G[1]; f2=G[2]; f3=G[3];
```
If the group `G` has been created as the subgroup of another group generated by a list of elements `L`, then the generating set returned by the function `gens` corresponds to `L`.

!!! note
    The output of `gens(G)` is not, in general, the minimal list of generators for `G`.

### Operations

Oscar supports the following operations and functions on group elements.

* `*` = multiplication between two elements in a group.
* `inv(x)` = ``x^{-1}`` the inverse of `x`.
* `x/y` = the element ``xy^{-1}``.
* `x^n` = the ``n``-th power of `x`. If ``n = 0``, the identity of the group is returned; if ``n < 0 ``, the ``-n``-th power of the inverse of `x` is returned.
* `isone(x)`: returns whether `x` is the identity of the group.
* `conj(x,y)` = `x^y` = the conjugate of `x` by `y`, i.e. the element ``y^{-1}xy``.
* `comm(x,y)` = the commutator of `x` and `y`, i.e. the element ``x^{-1}y^{-1}xy``.

!!! note
    In Oscar, the expression `x^y^z` is equivalent to `x^(y^z)`. In other words, conjugations are evaluated from the right to the left.


## [Subgroups](@id subgroups)

The subgroup of a group `G` generated by the elements `x,y,...` is defined by the following instruction:

* `sub(G, [x,y,...])` ;
* `sub(x,y,...)`.

This function returns two objects: a group `H`, that is the subgroup of `G` generated by the elements `x,y,...`, and the embedding homomorphism of `H` into `G`. The object `H` has the same type of `G`, and it has no memory of the "parent" group `G`: it is an independent group.

  **Examples:**
```jldoctest
julia> G = symmetric_group(4); H = sub(G,[cperm([1,2,3]),cperm([2,3,4])]);
julia> H[1] == alternating_group(4)
true
```
The following functions are available in Oscar for subgroup properties:
```@docs
issubgroup
embedding(G::T, H::T) where T <: GAPGroup
index(G::T, H::T) where T <: GAPGroup
isnormal(G::T, H::T) where T <: GAPGroup
ischaracteristic(G::T, H::T) where T <: GAPGroup
```

### Standard subgroups

The following functions are available in Oscar to obtain standard subgroups of a group `G`. Every such function returns a tuple `(H,f)`, where `H` is a group of the same type of `G` and `f` is the embedding homomorphism of `H` into `G`.

```@docs
trivial_subgroup
centre
sylow_subgroup(G::GAPGroup, p::Int64)
hall_subgroup(G::GAPGroup, P::AbstractVector{<:Base.Integer})
derived_subgroup
fitting_subgroup(G::GAPGroup)
frattini_subgroup(G::GAPGroup)
radical_subgroup(G::GAPGroup)
socle(G::GAPGroup)
```

The following functions return a list of subgroups.

```@docs
subgroups(G::GAPGroup)
normal_subgroups
maximal_subgroups
maximal_normal_subgroups
minimal_normal_subgroups
characteristic_subgroups
derived_series
sylow_system
hall_system
```

!!! note
    When a function returns a list of subgroups, the output consists in the subgroups only; the embeddings are not returned as well. To get the embedding homomorphism of the subgroup `H` in `G`, one has to type `embedding(G,H)`


## [Quotients](@id quotient)

Quotient groups in Oscar can be defined using the instruction `quo` in two ways.

* Quotients by normal subgroups.
```@docs
quo(G::T, H::T) where T <: GAPGroup
```

* Quotients by elements.
```@docs
quo(G::T, elements::Vector{S}) where T <: GAPGroup where S <: GAPGroupElem
```
This is the typical way to build finitely presented groups.

  **Example:**
```jldoctest
julia> F=free_group(2);
julia> (f1,f2)=gens(F);
julia> G=quo(F,[f1^2,f2^3,(f1*f2)^2])[1];
julia> isisomorphic(G,symmetric_group(3))[1]
true
```
Similarly to the subgroups, the output consists of a pair (`Q`,`p`), where `Q` is the quotient group and `p` is the projection homomorphism of `G` into `Q`.

## Permutation groups

Permutation groups can be defined as symmetric groups, alternating groups or their subgroups.

```@docs
symmetric_group
alternating_group
```

In Oscar, every permutation group has a degree `n`, that corresponds to the size of the set on which `G` acts. This can be displayed by typing
```julia
degree(G)
```

!!! note
    The degree of a group of permutations is not necessarily equal to the largest moved point of the group `G`. For example, the trivial subgroup of `symmetric_group(n)` has degree `n` even though it fixes `n`.

### Permutations

Permutations in Oscar are displayed as products of disjoint cycles, as in GAP. An explicit permutation can be built using the functions `perm`, `gap_perm` and `cperm`.

```@docs
perm
gap_perm
cperm
```

  **Example:**
```jldoctest
julia> perm(symmetric_group(6),[2,4,6,1,3,5])
(1,2,4)(3,6,5)

julia> cperm([1,2,3],4:7)
(1,2,3)(4,5,6,7)

julia> cperm([1,2],[2,3])
(1,3,2)
```

At the moment, the input vectors of the function `cperm` need not to be disjoint.

!!! warning
    If the function `perm` is evaluated in a vector of integers without specifying the group `G`, then the returned value is an element of the AbstractAlgebra.jl type `Perm{Int}`. For this reason, if one wants a permutation of type `GAPGroupElem{PermGroup}` without specifying a parent, one has to use the function `gap_perm`.


Every permutation has always a permutation group as a parent. Two permutations coincide if, and only if, they move the same points and their parent groups have the same degree.
```jldoctest
julia> G=symmetric_group(5);
julia> A=alternating_group(5);
julia> x=cperm(G,[1,2]);
julia> y=cperm(A,[1,2]);
julia> z=cperm([1,2]);
julia> x==y
true

julia> x==z
false
```
In the example above, `x` and `y` are equal because both act on a set of cardinality `5`, while `x` and `z` are different because `x` belongs to `Sym(5)` and `z` belongs to `Sym(2)`.


If `G` is a group and `x` is a permutation, it is possible to set `G` as parent of `x` simply typing `G(x)`. This returns the permutation `x` as element of `G` (or ERROR if `x` does not embed into `G`).
```@repl oscar
G=symmetric_group(5);
x=cperm([1,2,3]);
y=G(x);
parent(x)
parent(y)
```

The function `Vector{T}` works in the opposite way with respect to `perm`:
```@docs
Vector(x::PermGroupElem, n::Int = x.parent.deg)
```


#### Permutations as functions
A permutation can be viewed as a function on the set `{1,...,n}`, hence it can be evaluated on integers.

!!! note
    The multiplication between permutations works from the left to the right. So, if `x` and `y` are permutations and `n` is an integer, then `(x*y)(n) = (y(x(n))`, NOT `x(y(n))`.

```jldoctest
julia> x = cperm([1,2,3,4,5]);
julia> x(2)
3
```
This works also if the argument is not in the range `1:n`; in such a case, the output coincides with the input.



## Polycyclic groups

Julia has the following functions that allow to generate polycyclic groups:
```@docs
abelian_group(::Type{T}, v::Vector{Int}) where T <: GAPGroup
cyclic_group
dihedral_group
quaternion_group
```
!!! warning
    The type need to be specified in the input of the function `abelian_group`, otherwise a group of type `GrpAbFinGen` is returned, which is not a GAP group type. In future versions of Oscar, this may change.

The generators of a polycyclic group are displayed as `f1`, `f2`, `f3`, etc., and every element of a polycyclic group is displayed as product of such generators.

  **Example:**
```jldoctest
julia> G=abelian_group(PcGroup, [2,4]);
julia> G[1], G[2]
(f1, f2)
julia> G[2]*G[1]
f1*f2
```

Note that this does not define Julia variables named `f1`, `f2`, etc.! To get the generators of the group `G`, use `gens(G)`; for convenience they can also be accessed as `G[1]`, `G[2]`, as shown in Section [Elements of groups](@ref elements_of_groups).


## Matrix groups

In Oscar, a group of matrices over the field `F` is an object of parametric type `MatrixGroup{S,T}`, where `S` is the type of elements of `F` and `T` is (a subtype of) `MatElem{S}`. At the moment, `F` can be only a finite field.

  **Example:**
```jldoctest
julia> F=GF(3,1)[1];
julia> G=GL(2,F);
julia> typeof(G)
MatrixGroup{fq_nmod,fq_nmod_mat}
```

The parameters `S` and `T` are accessible via the functions `ring_elem_type` and `mat_elem_type`
```jldoctest
julia> ring_elem_type(MatrixGroup{fq_nmod,fq_nmod_mat})
fq_nmod
julia> mat_elem_type(MatrixGroup{fq_nmod,fq_nmod_mat})
fq_nmod_mat
```
The type of the elements in a matrix group is the parametric type `MatrixGroupElem{S,T}`, where the parameters are the same of the parent group. This is NOT a subtype of `BasicGAPGroupElem`, since the underlying object may be either a GAP matrix or a matrix of type `MatElem{S}`.

### Matrix groups constructors

A matrix group can be defined in two ways: as a known classical group, or as the subgroup generated by a given list of matrices.

The available classical groups in Oscar are the following:
```@docs
general_linear_group
special_linear_group
symplectic_group
orthogonal_group
special_orthogonal_group
omega_group
unitary_group
```
The standard copies of these groups rely on the corresponding GAP groups, described in the [GAP](https://www.gap-system.org/Manuals/doc/ref/chap50.html#X8674AAA578FE4AEE) website. An exception are the Omega groups, that are defined in a different way, in order to assure `omega_group(e,n,q)` to be a subgroup of `special_orthogonal_group(e,n,q)`.

The other way to build a matrix group, is via the following function
```@docs
matrix_group
```
Of course, the matrices in the vector `V` must have the same base ring and the same dimension.

!!! note
    The line `matrix_group(V)` is equivalent to `sub(GL(n,q),V)[1]`.


### Methods on matrix groups

The following methods are peculiarly available for matrix groups:
```@docs
base_ring(G::MatrixGroup)
degree(G::MatrixGroup)
```
  **Example:**
```jldoctest
julia> G=GL(4,4);
julia> degree(G)
4
julia> base_ring(G)
Finite field of degree 2 over F_2
```

### Elements of matrix groups

If `G` is a matrix group and `x` is either a matrix of type `MatElem{T}` or an element of another matrix group, it is possible to embed `x` into the matrix group `G` by typing `G(x)`.
```@repl oscar
F = GF(5,1)[1];
G = GL(3,F);
x = matrix(F,3,3,[1,2,0,0,1,4,0,0,1]);
G(x)
typeof(x)
typeof(G(x))
S = SL(3,F);
S(x)
S(G(x))
```
The operation `G(matrix(F,n,n,L))` can be abbreviated in `G(L)`. This allows to write down quickly an explicit element in a matrix group.
```jldoctest
julia> F = GF(3,1)[1];
julia> G = GL(3,F);
julia> G(matrix(F,3,3,[1,2,0,0,1,4,0,0,1]))==G([1,2,0,0,1,4,0,0,1])
true
```
Of course, the embedding `G(x)` returns an error whenever the matrix `x` does not belong to the group `G`. Also the line `x in G` returns an affirmative answer if `x` has type `MatElem`, but it lies in the group `G`, as shown below:
```jldoctest
julia> F=GF(3,1)[1];
julia> S=SL(2,F);
julia> G=GL(2,F);
julia> x=matrix(F,2,2,[1,0,0,2]);
julia> x in G
true
julia> x in S
false
```

If `x` is a `MatrixGroupElem{S,T}`, typing `matrix(x)` we get back the matrix of `x` of type `T`; somehow, the function `x -> matrix(x)` is a sort of inverse of `x -> G(x)`.
```jldoctest
julia> x = rand(GL(3,5));
julia> typeof(x)
MatrixGroupElem{fq_nmod,fq_nmod_mat}
julia> typeof(matrix(x))
fq_nmod_mat
```


### Methods and operations on elements

Many methods available for matrices can be computed in matrix group elements, such as `det`, `base_ring`, `nrows`, `trace`, `tr`. If `x` is a `MatrixGroupElem`, evaluating these functions in `x` is the same of evaluating them in `matrix(x)`.

The operations on group elements are available for matrix group elements too: `*`, `^`, `inv`, `comm`. Binary operations are allowed also between elements with different parent groups, as long as the degree and the base ring is the same (otherwise, an error is returned). Whenever a binary operation involves elements with different parent groups, the parent of the output is set by default as `GL(n,F)`, where `n` and `F` are the common degree and base ring respectively.

  **Example:**
```jldoctest
julia> O=GO(1,4,3);
julia> S=SL(4,3);
julia> x=O([1,0,0,0,0,1,0,0,0,0,2,0,0,0,0,1])
julia> y=S[1];
julia> parent(x*y)
GL(4,3)
julia> x*y in S, x*y in O
(false, false)
```

## Homomorphisms

In Oscar, a group homomorphism from `G` to `H` is an object of parametric type `GAPGroupHomomorphism{S,T}`, where `S` and `T` are the types of `G` and `H` respectively.

A homomorphism from `G` to `H` can be defined in two ways.

* Writing explicitly the images of the generators of `G`:
```julia
f = hom(G,H,[x1,x2,...],[y1,y2,...])
```
Here, `[x1,x2,...]` must be a generating set for `G` (not necessarily minimal) and `[y1,y2,...]` is a vector of elements of `H` of the same length of `[x1,x2,...]`. This assigns to `f` the value of the group homomorphism sending `x_i` into `y_i`. If such a homomorphism does not exist, an error is returned.

* Taking an existing function `g` satisfying the group homomorphism properties:
```julia
f = hom(G,H,g)
```
If the function `g` does not satisfy the group homomorphism properties, an error is returned.

  **Example:**
The following procedures define the same homomorphism (conjugation by `x`) in the two ways explained above.
```jldoctest
julia> S=symmetric_group(4);
julia> x=S[1];
julia> f=hom(S,S,gens(S),[S[1]^x,S[2]^x]);
julia> g=hom(S,S,y->y^x);
julia> f==g
true
```

Oscar has also the following standard homomorphism.
```@docs
id_hom
trivial_morphism
```

To evaluate the homomorphism `f` in the element `x` of `G`, it is possible to use the instruction
```julia
image(f,x)
```
or the more compact notations `f(x)` and `x^f`.

  **Example:**
```jldoctest
julia> S=symmetric_group(4);
julia> f=hom(S,S,x->x^S[1]);
julia> x=cperm(S,[1,2]);
julia> image(f,x)
(2,3)
julia> f(x)
(2,3)
julia> x^f
(2,3)
```

A sort of "inverse" of the evaluation is the following
```@docs
haspreimage(f::GAPGroupHomomorphism, x::GAPGroupElem)
```
  **Example:**
```jldoctest
julia> S=symmetric_group(4);
julia> f=hom(S,S,x->x^S[1]);
julia> x=cperm(S,[1,2]);
julia> haspreimage(f,x)
(true,(1,4))
```

!!! warning
    Do not confuse `haspreimage` with the function `has_preimage`, which works on variable of type `GrpGenToGrpGenMor`.

A further function that produces isomorphisms is `isisomorphic`:
```@docs
isisomorphic(G::GAPGroup, H::GAPGroup)
```

### Operations on homomorphisms

Oscar supports the following operations on homomorphisms.

* `inv(f)` = the inverse of `f`. An error is returned if `f` is not bijective.
* `f^n` = the homomorphism `f` composed `n` times with itself. An error is returned if the domain and the codomain of `f` do not coincide (unless `n=1`). If `n` is negative, the result is the inverse of `f` composed `n` times with itself.
* `compose(g,f)` = composition of `g` and `f`. This works only if the codomain of `g` coincide with the domain of `f`. Shorter equivalent expressions are `g*f` and `f(g)`.

  **Example:**
```jldoctest
julia> S=symmetric_group(4);
julia> f=hom(S,S,x->x^S[1]);
julia> g=hom(S,S,x->x^S[2]);
julia> f*g==hom(S,S,x->x^(S[1]*S[2]))
true
julia> f==f^-3
true
```

!!! note
    The composition operation `*` has to be read from the right to the left. So, `(f*g)(x)` is equivalent to `g(f(x))`.

### Properties of homomorphisms

Oscar implements the following attributes of homomorphisms.

```@docs
domain
codomain
isinjective(f::GAPGroupHomomorphism)
issurjective(f::GAPGroupHomomorphism)
isbijective(f::GAPGroupHomomorphism)
isinvertible(f::GAPGroupHomomorphism)
isinvariant(f::GAPGroupHomomorphism, H::GAPGroup)
```

### Subgroups described by homomorphisms

The following functions compute subgroups or quotients of either the domain or the codomain. Analogously to the functions described in Sections [Subgroups](@ref subgroups) and [Quotients](@ref quotient), the output consists of a pair (`H`, `g`), where `H` is a subgroup (resp. quotient) and `g` is its embedding (resp. projection) homomorphism.

```@docs
kernel(f::GAPGroupHomomorphism)
image(f::GAPGroupHomomorphism)
image(f::GAPGroupHomomorphism{S, T}, H::S) where S <: GAPGroup where T <: GAPGroup
cokernel(f::GAPGroupHomomorphism)
preimage(f::GAPGroupHomomorphism{S, T}, H::T) where S <: GAPGroup where T <: GAPGroup
```

## Automorphisms groups

Groups of automorphisms over a group `G` have parametric type `AutomorphismGroup{T}`, where `T` is the type of `G`. The group of automorphisms over a group `G` is defined by the following instruction:
```julia
automorphism_group(G)
```
The evaluation of the automorphism `f` in the element `x` is analogous to the homomorphism evaluation: it can be obtained by typing either `f(x)` or `x^f`.

It is possible to turn an automorphism `f` into a homomorphism by typing `hom(f)`. The viceversa is also possible: if `g` is a bijective homomorphism from the group `G` to itself and `A` is the automorphism group of `G`, then the instruction `A(g)` returns `g` as automorphism of `G`. This is the standard way to build explicitly an automorphism (another way, available for inner automorphisms, is shown in Section [Inner_automorphisms](@ref inner_automorphisms)).

  **Example:**
```jldoctest
julia> S=symmetric_group(4);
julia> A=automorphism_group(S);
julia> g=hom(S,S,x->x^S[1]);
julia> g in A
false
julia> au=A(g);
julia> au in A
true
julia> g=hom(au)
true
julia> x=cperm(S,[1,2,3]);
julia> au(x)
(2,3,4)
julia> g(x)==au(x)
true
```
In Oscar it is possible to multiply homomorphisms and automorphisms (whenever it makes sense); in such cases, the output is always a variable of type `GAPGroupHomomorphism{S,T}`.
```@repl oscar
S=symmetric_group(4);
A=automorphism_group(S);
g=hom(S,S,x->x^S[1]);
f=A(g);
typeof(g*f)
```

The following functions are available for automorphisms, some of them similar to the corresponding functions for homomorphisms of groups.
```@docs
isinvariant(f::GAPGroupElem{AutomorphismGroup{T}}, H::T) where T<:GAPGroup
restrict_automorphism(f::GAPGroupElem{AutomorphismGroup{T}}, H::T, A=automorphism_group(H)) where T <: GAPGroup
induced_automorphism(f::GAPGroupHomomorphism, mH::GAPGroupHomomorphism)
```

### [Inner automorphisms](@id inner_automorphisms)

Oscar disposes of the following functions to handle inner automorphisms of a group.
```@docs
inner_automorphism(g::GAPGroupElem)
isinner_automorphism(f::GAPGroupHomomorphism)
inner_automorphisms_group(A::AutomorphismGroup{T}) where T <: GAPGroup
```

