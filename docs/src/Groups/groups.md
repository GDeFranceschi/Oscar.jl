```@meta
CurrentModule = Oscar
```

```@setup oscar
using Oscar
```

```@contents
Pages = ["groups.md"]
```

# Groups


Oscar supports the following types of groups:

* `PermGroup` = groups of permutations
* `MatrixGroup` = groups of matrices
* `FPGroup` = finitely presented groups
* `PcGroup` = polycyclic groups
* `DirectProductOfGroups` = direct product of two groups
* `AutomorphismGroup` = group of automorphisms over a group


If `x` is an element of the group `G` of type `T`, then the type of `x` is `GAPGroupElement{T}`.

## Basics

### Elements of groups

Given a group `G`, it is always possible to have access to some particular elements.

```@docs
one(x::GAPGroup)
rand(::GAPGroup)
rand_pseudo(G::GAPGroup)
gens(::GAPGroup)
```

If the group `G` has been created as the subgroup of another group generated by a list of elements `L`, then the generating set returned by the function `gens` corresponds to `L`.

!!! note
    The output of `gens(G)` is not, in general, the minimal list of generators for `G`.

### Operations

Oscar supports the following operations and functions on group elements.

* `*` = multiplication between two elements in a group.
* `inv(x)` = `x^-1` the inverse of `x`.
* `x/y` = the element `x*y^-1`.
* `x^n` = the ``n``-th power of `x`. If ``n = 0``, the identity of the group is returned; if ``n < 0 ``, the ``n``-th power of the inverse of `x` is returned.
* `isone(x)`: returns whether `x` is the identity of the group.
* `conj(x,y)` = `x^y` = the conjugate of `x` by `y`, i.e. the element `x^-1*y*x`.
* `comm(x,y)` = the commutator of `x` and `y`, i.e. the element `x^-1*y^-1*x*y`.


## Subgroups

The subgroup of a group `G` generated by the elements `x,y,...` are defined by the following instruction:

* `sub(G, [x,y,...])` ;
* `sub(x,y,...)`.

This function returns two objects: a group `H`, that is the subgroup of `G` generated by the elements `x,y,...`, and the embedding homomorphism of `H` into `G`. The object `H` has the same type of `G`, and it has no memory of the "parent" group `G`: it is an independent group.
```@repl oscar
G = symmetric_group(4);
H = sub(G,[cperm([1,2,3]),cperm([2,3,4])]);
H[1] == alternating_group(4)
```


## Permutation groups

Permutation groups can be defined as symmetric groups, alternating groups or their subgroups.
```jldoctest
julia> degree(symmetric_group(4))
4
```

```@repl oscar
symmetric_group(4)
alternating_group(4)
```

Every permutation group `G` is identified by a degree, that corresponds ideally to the size of the set on which `G` is acting.

!!! note
    The degree of a group of permutations is not necessarily the highest moved point of the group `G`. For example, if `G` is defined as a   subgroup of `Sym(n)`, its degree is `n` even if every element of `G` fixes `n`.

### Permutations

Permutations in Oscar are displayed as products of disjoint cycles, as in GAP. A permutation can be defined in different ways.

* `perm(L)`: here, `L` is a vector ``[a_1, ... , a_n]`` containing one time each number from ``1`` to ``n`` for a certain positive integer ``n``. The output is the permutation over the set ``\{1, ... , n\}`` sending ``i`` into ``a_i`` for every ``i``. Example:
```jldoctest
julia> perm([2,4,6,1,3,5])
(1,2,4)(3,6,5)
```


* `cperm(L1,L2,...)`: here, the `L1`, `L2`, etc. are vectors of integers. Each vector is read as a cycle (e.g. the vector ``[1,2,3]`` corresponds to the cycle ``(1,2,3)``) and the output is the product of all the cycles. Each of these vectors need to contain all different numbers, but at the moment they are not required to be disjoint. Example:
```@repl oscar
cperm([1,2,3],[4,5,6])
cperm([1,2],[2,3])
```

Every permutation has always a permutation group as a parent. If a permutation is defined as above, the default parent is `Sym(n)`, where `n` is the highest moved point. It is possible to set another parent group for `perm` and `cperm` by adding the group at the begin of the list of arguments.
```@repl oscar
G = symmetric_group(5);
x = cperm([1,2]);
y = cperm(G,[1,2]);
parent(x)
parent(y)
```
Here, `x` and `y` belongs to different groups, although they are displayed in the same way.

Of course, the function `cperm(G,L)` returns an error if the degree of the group `G` is lower than the highest moved point of `L`.

If `G` is a group and `x` is a permutation, it is possible to set `G` as parent of `x` simply typing `G(x)`. This returns the permutation `x` as element of `G` (or ERROR if `x` does not embed into `G`).
```@repl oscar
G=symmetric_group(5);
x=cperm([1,2,3]);
y=G(x);
parent(x)
parent(y)
```

The function `listperm` works in the opposite way with respect to `perm`: given a permutation `x`, it returns the vector `[x(1), ... , x(n)]`, where `n` is the degree of `parent(x)`. In the example above, we would get
```@repl oscar
(x,y) = (cperm([1,2,3]), cperm(symmetric_group(5),[1,2,3])) # hide
listperm(x)
listperm(y)
```


#### Permutations as functions
A permutation can be viewed as a function on the set `{1,...,n}`, hence it can be evaluated on integers.
```@repl oscar
x = cperm([1,2,3,4,5]);
x(2)
```
This works also if the argument is not in the range `1:n`; in such a case, the output coincides with the input.

!!! note
    The multiplication between permutations works from the left to the right. So, if `x` and `y` are permutations and `n` is an integer, then `(x*y)(n) = (y(x(n))`, NOT `x(y(n))`.





